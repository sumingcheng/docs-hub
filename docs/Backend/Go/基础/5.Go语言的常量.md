# Go 常量

常量是使用 `const` 关键字定义的，其值在编译时设置，无法在运行时更改。

```go
package main

import "fmt"

func main() {
	const PI float32 = 3.14
	fmt.Println(PI)

	// 单个声明
	const name = "admin"

	// 多个声明
	const (
		a = 1
		b = 2
		c = 3
	)
	fmt.Println(a, b, c)

	// 使用 iota 批量声明常量
	const (
		num1 = iota
		num2
		num3
		num4
	)
	fmt.Println(num1, num2, num3, num4)

	// 匿名常量与 iota
	const (
		a1 = iota
		_
		b2
		_
		c3
	)
	fmt.Println(a1, b2, c3)
}
```

## 不可更改

一旦常量被定义，其值就不能被更改，尝试修改会导致编译错误。这确保了代码的安全性和可预测性。

## 无类型常量

Go 支持无类型常量，常量在需要时才会被赋予具体的类型。这意味着可以在不同的上下文中以不同的类型使用同一个常量。

## iota 的使用

`iota` 是 Go 语言中的一个预定义标识符，常用于枚举值的生成。在 `const` 声明块中，每新增一行常量声明，`iota` 的值就会自动递增 1。

```go
const (
	A = iota // A == 0
	B        // B == 1
	C        // C == 2
)
```

在这个例子中，`A`、`B`、`C` 分别被赋值为 0、1、2。

### 匿名常量与 iota

可以使用匿名常量 `_` 来跳过某些值。

```go
const (
	a = iota // a == 0
	_
	b        // b == 2
	_
	c        // c == 4
)
```

这样，`a`、`b`、`c` 的值分别是 0、2、4，中间的值被跳过。

## 数值精度

常量可以拥有高精度的数值。在编译时，Go 可以处理任意精度的数值常量，允许创建非常大或非常精确的常量值。

## 编译时验证

由于常量的值在编译时确定，所有与常量相关的操作都会在编译时进行验证。例如，不能将一个整数常量赋值给字符串类型的变量，否则会导致编译错误。

## 常量组和隐式重复

在连续的 `const` 声明块中，如果不提供新的值，后续的常量会隐式地使用前一个常量的值。

```go
const (
	x = 10
	y         // y == 10
	z = 20
	w         // w == 20
)
```

在这个例子中，`y` 将与 `x` 相同，`w` 将与 `z` 相同。

---

在使用常量时，我会注意以上这些特点，确保代码的正确性和可读性。
