---
authors: sumingcheng
---
# Go 为什么不推荐使用锁？



 **Link:** [https://zhuanlan.zhihu.com/p/663934560]



Go 语言的设计者通过引入通道（channels）和协程（goroutines）提供了一种新的并发模型，它旨在简化并发编程并避免常见的并发问题。虽然 Go 语言中也可以使用互斥锁（mutexes）和其他传统的并发控制机制，但通道提供了一种更高级、更直观的方式来处理并发。以下是为什么 Go 社区通常推荐首先考虑使用通道而不是锁的几个原因：

## 更简单、更直观  

通道提供了一种简单直观的方式来在协程之间发送数据和信号。通过使用通道，开发人员可以避免直接管理锁和共享内存，降低了编写并发代码的复杂性。

## 避免死锁和竞争条件  

通道通过串行化对共享数据的访问来避免竞争条件和死锁，这是传统的锁和共享内存模型中常见的问题。虽然使用通道仍然可能遇到死锁（例如，循环依赖），但通常更容易识别和解决。

## 提高代码的可读性和维护性  

使用通道使得并发逻辑更清晰、更易于理解和维护。通道的发送和接收操作明确地表达了协程之间的通信和同步意图。

## 方便的错误处理和资源清理  

通道提供了一种方便的方式来传播错误和通知协程结束，从而可以进行适当的资源清理和错误处理。

## 促进了“共享内存通过通信”（Share Memory By Communicating, SMC）的哲学  

Go 语言推广的“不要通过共享内存来通信，而是通过通信来共享内存”的哲学，通过通道实现了这种哲学，它鼓励开发人员使用通信而不是共享内存来组织并发逻辑。

## 更容易测试和调试  

使用通道通常使得并发代码更容易测试和调试，因为它简化了协程之间的交互和同步。

## 优雅的关闭和协程同步  

通过关闭通道和使用`select`语句，开发人员可以优雅地控制协程的关闭和同步，避免了复杂的锁逻辑和条件变量。

虽然通道是处理并发的推荐方式，但在某些情况下，使用锁可能仍然是必要的，特别是在需要精细控制并发访问的场景中。重要的是理解通道和锁的不同，以及它们各自的适用场景，以便能够选择最适合特定问题的解决方案。

