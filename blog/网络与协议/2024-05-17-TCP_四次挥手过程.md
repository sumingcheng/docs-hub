---
authors: sumingcheng
---
# TCP 四次挥手过程



 **Link:** [https://zhuanlan.zhihu.com/p/698328676]

## 四次挥手的步骤  
### 第一次挥手：客户端发送FIN  

* **动作**：客户端决定结束发送数据，向服务器发送一个带有FIN标志的数据包。
* **状态变迁**：客户端发送FIN后，进入FIN-WAIT-1状态，等待服务器的确认（ACK）。

### 第二次挥手：服务器发送ACK  

* **动作**：服务器收到客户端的FIN后，返回一个ACK数据包，确认序号为收到的序号加1。
* **状态变迁**：客户端接收到ACK后，进入FIN-WAIT-2状态。服务器进入CLOSE-WAIT状态，准备结束自己的发送。

### 第三次挥手：服务器发送FIN  

* **动作**：服务器完成其数据的发送后，向客户端发送一个带有FIN标志的数据包，请求关闭连接。
* **状态变迁**：服务器发送完FIN后，等待客户端的最终ACK确认，进入LAST-ACK状态。

### 第四次挥手：客户端发送ACK  

* **动作**：客户端收到服务器的FIN后，返回一个ACK数据包，确认序号为收到的序号加1。
* **状态变迁**：客户端发送ACK后，进入TIME-WAIT状态，保持该状态足够的时间以确保服务器接收到ACK。该时间通常是最大报文段生存时间（Maximum Segment Lifetime, MSL）的两倍。完成这个等待后，客户端最终转入CLOSED状态。

| 方向 | 描述 | 客户端状态 | 服务器状态 |
| --- | --- | --- | --- |
| 客户端 -> 服务器 | 客户端发送FIN，请求关闭连接 | FIN\_WAIT\_1 | - |
| 服务器 -> 客户端 | 服务器确认，发送ACK响应 | FIN\_WAIT\_2 | CLOSE\_WAIT |
| 服务器 -> 客户端 | 服务器发送FIN，请求关闭连接 | - | LAST\_ACK |
| 客户端 -> 服务器 | 客户端发送ACK，确认收到关闭请求 | TIME\_WAIT | CLOSED |

## 为什么挥手需要四次？  

为了保证数据完整传输

## CLOSE-WAIT  

等待关闭

## TIME-WAIT  

为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接

## 如何查看TIME-WAIT状态的链接数量？  
```
netstat -an |grep TIMEWAIT|wc -l 查看连接数等待timewait状态连接数
```
## 为什么会TIME-WAIT过多？解决方法是怎样的？  

* **高频短连接**：如果应用频繁地建立并快速关闭连接，那么在任意时刻都可能有大量的连接处于TIME-WAIT状态。这种情况在使用不当的客户端-服务器通信模型中很常见，如每个请求都建立新连接的HTTP/1.0。而HTTP/1.1默认支持 HTTP Keep-Alive
* **资源消耗**：每个处于TIME-WAIT的连接都会占用服务器资源（如端口和内存），过多的TIME-WAIT连接可能耗尽这些资源，导致性能下降或无法建立新的连接。
